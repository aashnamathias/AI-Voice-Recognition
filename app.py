# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-q3bABvYx_c-UUyUN-Ep5BHoKysyeDhj
"""

import streamlit as st
from transformers import Wav2Vec2Processor, Wav2Vec2ForCTC
import torch
import torchaudio
import tempfile
import soundfile as sf
import numpy as np

st.title("üéôÔ∏è Voice Recognition")

# Basic sentence segmentation (adjust max_words as needed)
def segment_and_punctuate(text, max_words=15):
    words = text.split()
    segments = []
    current_segment = []
    for word in words:
        current_segment.append(word)
        if len(current_segment) >= max_words:
            segments.append(" ".join(current_segment) + ".")
            current_segment = []
    if current_segment:
        segments.append(" ".join(current_segment) + ".")
    return " ".join(segments)

# def segment_and_capitalize(text, min_words=10, max_words=20):
#     words = text.split()
#     segments = []
#     current_segment = []
#     word_count = 0
#     for word in words:
#         current_segment.append(word)
#         word_count += 1
#         if word_count >= max_words:
#             segment = " ".join(current_segment)
#             if segment:
#                 segments.append(segment[0].upper() + segment[1:] + ".")
#             current_segment = []
#             word_count = 0
#     if current_segment:
#         segment = " ".join(current_segment)
#         if segment:
#             segments.append(segment[0].upper() + segment[1:] + ".")
#     return " ".join(segments)

def capitalize_first_letter(punctuated_text):
    segments = punctuated_text.split(".")
    capitalized_segments = []
    for segment in segments:
        stripped_segment = segment.strip()
        if stripped_segment:
            first_word = stripped_segment.split()[0]
            rest_of_segment = " ".join(stripped_segment.split()[1:])
            capitalized_segments.append(first_word[0].upper() + first_word[1:].lower() + (" " + rest_of_segment.lower() if rest_of_segment else ""))
        else:
            capitalized_segments.append("")
    return ". ".join(capitalized_segments).strip() + "." if capitalized_segments else ""

# Load Wav2Vec2 models
@st.cache_resource
def load_asr_model():
    processor = Wav2Vec2Processor.from_pretrained("facebook/wav2vec2-large-960h-lv60-self")
    model = Wav2Vec2ForCTC.from_pretrained("facebook/wav2vec2-large-960h-lv60-self")
    return processor, model

processor, model = load_asr_model()

uploaded_file = st.file_uploader("Upload a WAV file", type=["wav"])

if uploaded_file is not None:
    st.audio(uploaded_file)
    with tempfile.NamedTemporaryFile(delete=False) as tmp:
        tmp.write(uploaded_file.read())
        tmp_path = tmp.name
    try:
        audio, sampling_rate = sf.read(tmp_path)
        speech_array = audio.astype("float32")
        if len(speech_array.shape) > 1:
            speech_array = speech_array.mean(axis=1)
    except Exception as e:
        st.error(f"Error loading audio file: {e}")
        st.stop()

    # Resample to 16000 Hz if necessary
    if sampling_rate != 16000:
        resampler = torchaudio.transforms.Resample(orig_freq=sampling_rate, new_freq=16000)
        speech = resampler(torch.tensor(speech_array).unsqueeze(0)).squeeze().numpy()
    else:
        speech = speech_array

    # Process the speech input
    inputs = processor(speech, sampling_rate=16000, return_tensors="pt", padding=True)

    # Transcription
    with st.spinner("Transcribing... please wait ‚è≥"):
        with torch.no_grad():
            logits = model(**inputs).logits
        predicted_ids = torch.argmax(logits, dim=-1)
        transcription = processor.decode(predicted_ids[0])

    st.markdown("### ‚úèÔ∏è Raw Transcription:")
    st.success(transcription)
    st.markdown(f"**üî¢ Word Count:** {len(transcription.split())}")

    # Basic Punctuation
    with st.spinner("Adding basic punctuation... ‚úçÔ∏è"):
        punctuated_text = segment_and_punctuate(transcription)
        # punctuated_text = segment_and_capitalize(transcription)
        capitalized_text = capitalize_first_letter(punctuated_text)
        st.markdown("### üìù Transcription with Basic Punctuation:")
        st.info(capitalized_text)
